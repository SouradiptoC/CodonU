:py:mod:`CodonU.analyzer`
=========================

.. py:module:: CodonU.analyzer


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   aromaticity_comp/index.rst
   cai_comp/index.rst
   cbi_comp/index.rst
   enc_comp/index.rst
   generate_report/index.rst
   generate_report_summary/index.rst
   gravy_comp/index.rst
   internal_comp/index.rst
   rscu_comp/index.rst
   tRNA_comp/index.rst


Package Contents
----------------


Functions
~~~~~~~~~

.. autoapisummary::

   CodonU.analyzer.calculate_cai
   CodonU.analyzer.calculate_rscu
   CodonU.analyzer.calculate_cbi
   CodonU.analyzer.calculate_enc
   CodonU.analyzer.calculate_gravy
   CodonU.analyzer.calculate_aromaticity
   CodonU.analyzer.get_anticodon_count_dict
   CodonU.analyzer.calculate_gtai
   CodonU.analyzer.generate_report_summary
   CodonU.analyzer.generate_report
   CodonU.analyzer.is_not_bad_seq
   CodonU.analyzer.not_contains_amb_letter
   CodonU.analyzer.g3
   CodonU.analyzer.a3
   CodonU.analyzer.gc_123
   CodonU.analyzer.at_123
   CodonU.analyzer.custom_codon_table
   CodonU.analyzer.filter_reference
   CodonU.analyzer.reverse_table
   CodonU.analyzer.syn_codons
   CodonU.analyzer.sf_vals
   CodonU.analyzer.rscu
   CodonU.analyzer.weights_for_cai
   CodonU.analyzer.cai
   CodonU.analyzer.cbi
   CodonU.analyzer.enc
   CodonU.analyzer.gravy
   CodonU.analyzer.aromaticity



.. py:function:: calculate_cai(handle: str, genetic_code_num: int, min_len_threshold: int = 200, gene_analysis: bool = False, save_file: bool = False, file_name: str = 'CAI_report', folder_path: str = 'Report') -> dict[str, float | dict[str, float]]

   Calculates cai values for each codon

   :param handle: Handle to the file, or the filename as a string
   :param genetic_code_num: Genetic table number for codon table
   :param min_len_threshold: Minimum length of nucleotide sequence to be considered as gene
   :param gene_analysis: Option if gene analysis (True) or genome analysis (False) (optional)
   :param save_file: Option for saving the values in xlsx format (Optional)
   :param file_name: Intended file name (Optional)
   :param folder_path: Folder path where image should be saved (optional)
   :return: The dictionary containing codon and cai value pairs if gene_analysis is False, otherwise returns the
   dictionary containing gene name and corresponding codon and cai value pairs


.. py:function:: calculate_rscu(handle: str, genetic_code_num: int, min_len_threshold: int = 200, gene_analysis: bool = False, save_file: bool = False, file_name: str = 'RSCU_report', folder_path: str = 'Report') -> dict[str, float | dict[str, float]]

   Calculates rscu values for each codon

   :param handle: Handle to the file, or the filename as a string
   :param genetic_code_num: Genetic table number for codon table
   :param min_len_threshold: Minimum length of nucleotide sequence to be considered as gene
   :param gene_analysis: Option if gene analysis (True) or genome analysis (False) (optional)
   :param save_file: Option for saving the values in xlsx format (Optional)
   :param file_name: Intended file name (Optional)
   :param folder_path: Folder path where image should be saved (optional)
   :return: The dictionary containing codon and rscu value pairs if gene_analysis is false, otherwise the dictionary containing the gene name and the codon & rscu value pairs


.. py:function:: calculate_cbi(handle: str, genetic_code_num: int, min_len_threshold: int = 66, gene_analysis: bool = False, save_file: bool = False, file_name: str = 'CBI_report', folder_path: str = 'Report') -> dict[str, tuple[float, str] | dict[str, tuple[float, str]]]

   Calculates cbi values for each amino acid based on Bennetzen and Hall (1982)

   :param handle: Handle to the file, or the filename as a string
   :param genetic_code_num: Genetic table number for codon table
   :param min_len_threshold: Minimum length of nucleotide sequence to be considered as gene
   :param gene_analysis: Option if gene analysis (True) or genome analysis (False) (optional)
   :param save_file: Option for saving the values in xlsx format (Optional)
   :param file_name: Intended file name (Optional)
   :param folder_path: Folder path where image should be saved (optional)
   :return: The dictionary containing amino acid and cbi value, optimal codon pairs if gene_analysis is false,
   otherwise returns the dictionary containing gene name and dictionary containing amino acid and cbi value,
   optimal codon pairs
    


.. py:function:: calculate_enc(handle: str, genetic_code_num: int, min_len_threshold=200, gene_analysis: bool = False, save_file: bool = False, file_name: str = 'ENc_report', folder_path: str = 'Report') -> float or dict[str, float]

   Calculates ENc value for a given sequences

   :param handle: Handle to the file, or the filename as a string
   :param genetic_code_num: Genetic table number for codon table
   :param min_len_threshold: Minimum length of nucleotide sequence to be considered as gene
   :param gene_analysis: Option if gene analysis (True) or genome analysis (False) (optional)
   :param save_file: Option for saving the values in xlsx format (Optional)
   :param file_name: Intended file name (Optional)
   :param folder_path: Folder path where image should be saved (optional)
   :return: The ENc value if gene_analysis is false, else a dictionary containing gene number and corresponding ENc value


.. py:function:: calculate_gravy(handle: str, min_len_threshold: int = 66, gene_analysis: bool = False, save_file: bool = False, file_name: str = 'GRAVY_report', folder_path: str = 'Report') -> dict[str, float] | float

   Calculates the gravy score for a given protein sequence according to Kyte and Doolittle (1982)

   :param handle: Handle to the file, or the filename as a string
   :param min_len_threshold: Minimum length of protein sequence to be considered as gene
   :param gene_analysis: Option if gene analysis (True) or genome analysis (False) (optional)
   :param save_file: Option for saving the values in xlsx format (Optional)
   :param file_name: Intended file name (Optional)
   :param folder_path: Folder path where image should be saved (optional)
   :return: The GRAVY score of given sequence if gene_analysis is false, else the dictionary containing gene number and corresponding GRAVY score


.. py:function:: calculate_aromaticity(handle: str, min_len_threshold: int = 66, gene_analysis: bool = False, save_file: bool = False, file_name: str = 'Aroma_report', folder_path: str = 'Report') -> dict[str, float] | float

   Calculates the aromaticity score for a given protein sequence according to Lobry (1994)

   :param handle: Handle to the file, or the filename as a string
   :param min_len_threshold: Minimum length of protein sequence to be considered as gene
   :param gene_analysis: Option if gene analysis (True) or genome analysis (False) (optional)
   :param save_file: Option for saving the values in xlsx format (Optional)
   :param file_name: Intended file name (Optional)
   :param folder_path: Folder path where image should be saved (optional)
   :return: The aromaticity score of given sequence if gene_analysis is false, else the dictionary containing
   gene number and corresponding GRAVY score


.. py:function:: get_anticodon_count_dict(url: str, database: str) -> dict[str, int]

   Retrieves the anticodon table from given link

   **NOTE:** The *database* can have only two values, i.e. "*tRNADB_CE*" and "*GtRNAdb*"
       * For using *tRNADB_CE*, please visit http://trna.ie.niigata-u.ac.jp/cgi-bin/trnadb/index.cgi
       * For using *GtRNAdb*, please visit http://gtrnadb.ucsc.edu/

   :param url: URL to anticodon table
   :param database: Type of database from the above options
   :return: The dictionary containing anticodon as key and count as val
   :raise UnsupportedDatabase: If *database* has other values than mentioned


.. py:function:: calculate_gtai(handle: str, anticodon_dict: dict, genetic_code_num: int, reference: Optional[str] = None, size_pop: int = 60, generation_num: int = 100, save_file: bool = False, file_name: str = 'tAI_report', folder_path: str = 'Report') -> tuple[pandas.DataFrame, pandas.DataFrame, pandas.DataFrame]

       Calculates the gtAI value for each gene according to Anwar et al., 2023

       The function returns following dataframes:
           * tai_df: The dataframe contains gene description and tAI values
           * abs_wi_df: The dataframe contains each anticodon and absolute weights according to the paper
           * rel_wi_df: The dataframe contains each anticodon and relative weights according to the paper
       
   **Note:** The function will generate a file named 'best_fit.py'

       :param handle: Path to the fasta file as a string
       :param anticodon_dict: The dictionary containing anticodon as key and count as value
       :param genetic_code_num: Genetic table number for codon table
       :param reference: Path to the reference fasta file as a string (Optional)
       :param size_pop: A parameter for the genetic algorithm to identify the population size (Optional)
       :param generation_num: A parameter for the genetic algorithm to identify the generation number (Optional)
       :param save_file: Option for saving the values in xlsx format (Optional)
       :param file_name: Intended file name (Optional)
       :param folder_path: Folder path where image should be saved (optional)
       :return: A tuple of 3 dataframes, as discussed earlier
       :raises FileExistsError: If re-write permission is not given for the file `best_fit.py`
       :raises ImportError: If `best_fit.py` is not created or deleted after creation
       


.. py:function:: generate_report_summary(handle: str, _type: str, genetic_code_num: int, min_len_threshold: int, res_folder_path: str = 'Report')

   Generate the report for given sequence **[best for genome analysis]**

   For nucleotide sequence, this generates reports of:
       - RSCU
       - CAI
       - CBI
       - ENc

   For protein sequence, this generates reports of:
       - GRAVY score
       - Aromaticity score


   **NOTE** Possible types are
       - nuc: For nucleotide sequence
       - aa: For protein sequence

   :param handle: Handle to the file, or the filename as a string
   :param _type: Type of the sequence [nuc or aa]
   :param genetic_code_num: Genetic table number for codon table
   :param min_len_threshold: Minimum length of sequence to be considered as gene
   :param res_folder_path: The path of folder where the file will be saved


.. py:function:: generate_report(handle: str, _type: str, genetic_code_num: int, min_len_threshold: int, res_folder_path: str = 'Report')

   Generate the report for given sequence **[best for gene analysis]**

   For nucleotide sequence, this generates reports of:
       - RSCU
       - CAI
       - CBI
       - ENc

   For protein sequence, this generates reports of:
       - GRAVY score
       - Aromaticity score


   **NOTE** Possible types are
       - nuc: For nucleotide sequence
       - aa: For protein sequence

   :param handle: Handle to the file, or the filename as a string
   :param _type: Type of the sequence [nuc or aa]
   :param genetic_code_num: Genetic table number for codon table
   :param min_len_threshold: Minimum length of sequence to be considered as gene
   :param res_folder_path: The path of folder where the file will be saved
   :return:


.. py:exception:: NoSynonymousCodonWarning(aa)

   Bases: :py:obj:`CodonU.cua_warnings.codon_usage_warns.CodonUsageWarning`

   Occurs when only one codon in the given reference sequence list translates to a certain amino acid

   .. py:method:: warn()



.. py:exception:: MissingCodonWarning(aa: str)

   Bases: :py:obj:`CodonU.cua_warnings.codon_usage_warns.CodonUsageWarning`

   Occurs when no codon in the given reference sequence list translates to a certain amino acid

   .. py:method:: warn()



.. py:exception:: NoProteinError(seq)

   Bases: :py:obj:`CodonU.cua_errors.codon_usage_err.CodonUsageError`

   Occurs when a complete category of amino acid based on sf values is not translated by the provided sequence


.. py:exception:: CodonTableExistsError(code, val)

   Bases: :py:obj:`CodonU.cua_errors.codon_usage_err.CodonUsageError`

   Occurs when id, name or alt_name of a new table is same with existing tables


.. py:exception:: BadSequenceError(seq, code)

   Bases: :py:obj:`CodonU.cua_errors.codon_usage_err.CodonUsageError`

   Occurs when the sequence is bad i.e. length of the sequence is not divisible by 3


.. py:exception:: NucleotideError(code)

   Bases: :py:obj:`CodonU.cua_errors.codon_usage_err.CodonUsageError`

   Occurs when an ambiguous or invalid nucleotide is present in genome


.. py:function:: is_not_bad_seq(seq: Seq | str, code: int, _type: str) -> bool

   Checks if the sequence is bad i.e. length of the sequence is not divisible by 3

   :param seq: The nucleotide sequence
   :param code: The code to call BadSequenceError (1 or 2)
   :param _type: Type of sequence, i.e. 'nuc'
   :return: True if seq is not bad
   :raises BadSequenceError: If the seq is bad


.. py:function:: not_contains_amb_letter(seq: Seq | str) -> bool

   Checks if provided sequence contains ambiguous DNA letters

   :param seq: Provided sequence
   :return: True if sequence does not contain ambiguous letter
   :raise NucleotideError: If sequence contain ambiguous letter


.. py:function:: g3(seq: Seq | str) -> float

   Calculates percentage of G content for third position

   :param seq: Provided sequence
   :return: Percentage of G content


.. py:function:: a3(seq: Seq | str) -> float

   Calculates percentage of A content for third position

   :param seq: Provided sequence
   :return: Percentage of A content


.. py:function:: gc_123(seq: Seq | str) -> tuple[float, float | int, float | int, float | int]

   Calculate G+C content: total, for first, second and third positions

   :param seq: Provided sequence
   :return: The G+C percentage for the entire sequence, and the three codon positions


.. py:function:: at_123(seq: Seq | str) -> tuple[float, float | int, float | int, float | int]

   Calculate G+C content: total, for first, second and third positions

   :param seq: Provided sequence
   :return: The A+T percentage for the entire sequence, and the three codon positions


.. py:function:: custom_codon_table(name: str, alt_name: Optional[str], genetic_code_id: int, forward_table: dict[str, str], start_codons: list[str], stop_codons: list[str]) -> None

   Registers a new Codon Table as provided by the user. 

   **Note**: The scope of the newly registered table is limited to the working file only

   :param name: Name for the table
   :param alt_name: Short name for the table
   :param genetic_code_id: Genetic code number for the table
   :param forward_table: A dict containing mapping of codons to proteins [excluding stop codons]
   :param start_codons: A list of possible start codons
   :param stop_codons: A list of possible stop codons
   :raises CodonTableExistsError: If the name, alt_name or genetic_code_id already exists


.. py:function:: filter_reference(records, min_len_threshold: int, _type: str) -> list[Bio.SeqRecord.SeqRecord]

   Filters the list of reference based on given threshold of length

   :param records: A generator object holding the sequence objects
   :param min_len_threshold: Minimum length of nucleotide sequence to be considered as gene
   :param _type: Type of sequence, i.e. 'nuc' or 'aa
   :return: The list of usable sequences


.. py:function:: reverse_table(codon_table: Bio.Data.CodonTable.NCBICodonTableDNA) -> dict[str, list[str]]

   Creates the protein, codon dictionary where protein is key 

   e.g. 'L': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG']

   :param codon_table: The codon table
   :return: The dict having protein as key


.. py:function:: syn_codons(codon_table: Bio.Data.CodonTable.NCBICodonTableDNA) -> dict[str, list[str]]

   Creates the codon, synonymous codon family dictionary where codon is the key 

   e.g. 'TTA': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG']

   :param codon_table: The codon table
   :return: The dict having individual codons as keys


.. py:function:: sf_vals(codon_table: Bio.Data.CodonTable.NCBICodonTableDNA) -> dict[int, list[str]]

   Creates the sf value and protein dictionary where sf value is key 

   e.g. 6: ['L', 'S', 'R']

   :param codon_table: The codon table
   :return: The dict having sf values as key


.. py:function:: rscu(references: list[Seq | str], genetic_code: int) -> dict[str, float]

   Calculates relative synonymous codon usage (RSCU) value for a given nucleotide sequence according to Sharp and Li (1987)

   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: A dictionary containing codons and their respective RSCU values


.. py:function:: weights_for_cai(references: list[Seq | str], genetic_code: int) -> dict[str, float]

   Calculates relative adaptiveness/weight value for a given nucleotide sequence according to Sharp and Li (1987)

   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: A dictionary containing codons and their respective weights


.. py:function:: cai(nuc_seq: Seq | str, references: list[Seq | str], genetic_code: int) -> float

   Calculates Codon Adaptive Index (CAI) value for a given nucleotide sequence according to Sharp and Li (1987)

   :param nuc_seq: The Nucleotide Sequence
   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: The CAI value for given sequence


.. py:function:: cbi(prot_seq: Seq | str, references: list[Seq | str], genetic_code: int) -> tuple[float, str]

   Calculates codon bias index (CBI) for a given protein seq based on Bennetzen and Hall (1982)

   :param prot_seq: The Protein Sequence
   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: A tuple of CBI val and the optimal codon
   :raises NoSynonymousCodonWarning: When there is no synonymous codons
   :raises MissingCodonWarning: When no codons translate to provided Amino acid


.. py:function:: enc(references: list[Seq | str], genetic_code: int) -> float

   Calculates Effective number of codons (Enc) based on Wright (1989) and Fuglsang (2004)

   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: Calculated Enc value for the sequence(s)
   :raises MissingCodonWarning: If there is no codon for a certain amino acid
   :raises NoProteinError: If there is no codon for a certain set of amino acid


.. py:function:: gravy(seq: Seq | str) -> float

   Computes the GRAVY score according to Kyte and Doolittle (1982)

   :param seq: Protein sequence
   :return: The GRAVY score


.. py:function:: aromaticity(seq: Seq | str) -> float

   Calculate the aromaticity score according to Lobry (1994).

   :param seq: Protein sequence
   :return: The aromaticity score


