:py:mod:`CodonU.analyzer.internal_comp`
=======================================

.. py:module:: CodonU.analyzer.internal_comp


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   CodonU.analyzer.internal_comp.is_not_bad_seq
   CodonU.analyzer.internal_comp.not_contains_amb_letter
   CodonU.analyzer.internal_comp.g3
   CodonU.analyzer.internal_comp.a3
   CodonU.analyzer.internal_comp.gc_123
   CodonU.analyzer.internal_comp.at_123
   CodonU.analyzer.internal_comp.custom_codon_table
   CodonU.analyzer.internal_comp.filter_reference
   CodonU.analyzer.internal_comp.reverse_table
   CodonU.analyzer.internal_comp.syn_codons
   CodonU.analyzer.internal_comp.sf_vals
   CodonU.analyzer.internal_comp.rscu
   CodonU.analyzer.internal_comp.weights_for_cai
   CodonU.analyzer.internal_comp.cai
   CodonU.analyzer.internal_comp.cbi
   CodonU.analyzer.internal_comp.enc
   CodonU.analyzer.internal_comp.gravy
   CodonU.analyzer.internal_comp.aromaticity



.. py:function:: is_not_bad_seq(seq: Seq | str, code: int, _type: str) -> bool

   Checks if the sequence is bad i.e. length of the sequence is not divisible by 3

   :param seq: The nucleotide sequence
   :param code: The code to call BadSequenceError (1 or 2)
   :param _type: Type of sequence, i.e. 'nuc'
   :return: True if seq is not bad
   :raises BadSequenceError: If the seq is bad


.. py:function:: not_contains_amb_letter(seq: Seq | str) -> bool

   Checks if provided sequence contains ambiguous DNA letters

   :param seq: Provided sequence
   :return: True if sequence does not contain ambiguous letter
   :raise NucleotideError: If sequence contain ambiguous letter


.. py:function:: g3(seq: Seq | str) -> float

   Calculates percentage of G content for third position

   :param seq: Provided sequence
   :return: Percentage of G content


.. py:function:: a3(seq: Seq | str) -> float

   Calculates percentage of A content for third position

   :param seq: Provided sequence
   :return: Percentage of A content


.. py:function:: gc_123(seq: Seq | str) -> tuple[float, float | int, float | int, float | int]

   Calculate G+C content: total, for first, second and third positions

   :param seq: Provided sequence
   :return: The G+C percentage for the entire sequence, and the three codon positions


.. py:function:: at_123(seq: Seq | str) -> tuple[float, float | int, float | int, float | int]

   Calculate G+C content: total, for first, second and third positions

   :param seq: Provided sequence
   :return: The A+T percentage for the entire sequence, and the three codon positions


.. py:function:: custom_codon_table(name: str, alt_name: Optional[str], genetic_code_id: int, forward_table: dict[str, str], start_codons: list[str], stop_codons: list[str]) -> None

   Registers a new Codon Table as provided by the user. 

   **Note**: The scope of the newly registered table is limited to the working file only

   :param name: Name for the table
   :param alt_name: Short name for the table
   :param genetic_code_id: Genetic code number for the table
   :param forward_table: A dict containing mapping of codons to proteins [excluding stop codons]
   :param start_codons: A list of possible start codons
   :param stop_codons: A list of possible stop codons
   :raises CodonTableExistsError: If the name, alt_name or genetic_code_id already exists


.. py:function:: filter_reference(records, min_len_threshold: int, _type: str) -> list[Bio.SeqRecord.SeqRecord]

   Filters the list of reference based on given threshold of length

   :param records: A generator object holding the sequence objects
   :param min_len_threshold: Minimum length of nucleotide sequence to be considered as gene
   :param _type: Type of sequence, i.e. 'nuc' or 'aa
   :return: The list of usable sequences


.. py:function:: reverse_table(codon_table: Bio.Data.CodonTable.NCBICodonTableDNA) -> dict[str, list[str]]

   Creates the protein, codon dictionary where protein is key 

   e.g. 'L': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG']

   :param codon_table: The codon table
   :return: The dict having protein as key


.. py:function:: syn_codons(codon_table: Bio.Data.CodonTable.NCBICodonTableDNA) -> dict[str, list[str]]

   Creates the codon, synonymous codon family dictionary where codon is the key 

   e.g. 'TTA': ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG']

   :param codon_table: The codon table
   :return: The dict having individual codons as keys


.. py:function:: sf_vals(codon_table: Bio.Data.CodonTable.NCBICodonTableDNA) -> dict[int, list[str]]

   Creates the sf value and protein dictionary where sf value is key 

   e.g. 6: ['L', 'S', 'R']

   :param codon_table: The codon table
   :return: The dict having sf values as key


.. py:function:: rscu(references: list[Seq | str], genetic_code: int) -> dict[str, float]

   Calculates relative synonymous codon usage (RSCU) value for a given nucleotide sequence according to Sharp and Li (1987)

   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: A dictionary containing codons and their respective RSCU values


.. py:function:: weights_for_cai(references: list[Seq | str], genetic_code: int) -> dict[str, float]

   Calculates relative adaptiveness/weight value for a given nucleotide sequence according to Sharp and Li (1987)

   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: A dictionary containing codons and their respective weights


.. py:function:: cai(nuc_seq: Seq | str, references: list[Seq | str], genetic_code: int) -> float

   Calculates Codon Adaptive Index (CAI) value for a given nucleotide sequence according to Sharp and Li (1987)

   :param nuc_seq: The Nucleotide Sequence
   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: The CAI value for given sequence


.. py:function:: cbi(prot_seq: Seq | str, references: list[Seq | str], genetic_code: int) -> tuple[float, str]

   Calculates codon bias index (CBI) for a given protein seq based on Bennetzen and Hall (1982)

   :param prot_seq: The Protein Sequence
   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: A tuple of CBI val and the optimal codon
   :raises NoSynonymousCodonWarning: When there is no synonymous codons
   :raises MissingCodonWarning: When no codons translate to provided Amino acid


.. py:function:: enc(references: list[Seq | str], genetic_code: int) -> float

   Calculates Effective number of codons (Enc) based on Wright (1989) and Fuglsang (2004)

   :param references: List of reference nucleotide sequences
   :param genetic_code: Genetic table number for codon table
   :return: Calculated Enc value for the sequence(s)
   :raises MissingCodonWarning: If there is no codon for a certain amino acid
   :raises NoProteinError: If there is no codon for a certain set of amino acid


.. py:function:: gravy(seq: Seq | str) -> float

   Computes the GRAVY score according to Kyte and Doolittle (1982)

   :param seq: Protein sequence
   :return: The GRAVY score


.. py:function:: aromaticity(seq: Seq | str) -> float

   Calculate the aromaticity score according to Lobry (1994).

   :param seq: Protein sequence
   :return: The aromaticity score


